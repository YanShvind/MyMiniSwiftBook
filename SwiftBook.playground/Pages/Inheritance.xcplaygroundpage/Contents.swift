
// наследование
// это значит, что классы могут быть созданы не с нуля, а на базе уже существующих классов.
// При этом все свойства, методы и сабскрипты старшего класса включаются в состав нового.
// При наследовании старший класс называется суперклассом
// Наследование доступно только при работе с классами. Структуры не поддерживают наследование.

// суперкласс
class Quadruped {
    var type = ""
    var name = ""
    func walk() {
        print("walk")
    }
}
// подкласс
class Dog: Quadruped {
func bark() {
        print("woof")
    }
}
var dog = Dog()
dog.type = "dog"
dog.walk() // выводит walk
dog.bark() // выводит woof

print()
// Для переопределения параметров суперкласса в подклассе необходимо указать ключевое слово override перед определением элемента.
// С помощью ключевого слова override мы сообщаем Swift, что метод bark() в клас- се NoisyDog имеет собственную реализацию.
class NoisyDog: Dog {
    override func bark() {
        print ("woof")
        print ("woof")
        print ("woof")
} }
var badDog = NoisyDog()
badDog.bark()

print()
// чтобы захватить и значение родительского метода ставим super
// Swift позволяет осуществлять доступ внутри производного класса к переопределенным элементам суперкласса.
// Для этого в качестве префикса имени элемента вместо self используется ключевое слово super.
// В предыдущем примере в методе bark() класса NoisyDog происходит дублирование кода.
// Перепишем реализацию метода bark() таким образом, чтобы избежать дублирования кода
class NoisyDog1: Dog {
    override func bark() {
        for _ in 1...3 {
            super.bark()
        }
} }
var badDog1 = NoisyDog1()
badDog1.bark()
